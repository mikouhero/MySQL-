# 07 | 行锁

### 1、行锁
>顾名思义，行锁就是针对数据表中行记录的锁。这很好理解，比如事务 A 更新了一行，而这个时候事务B也要更新同一行，则必须等事务A执行完才能更新。

### 2、两阶段
**`在InnoDB 事务中，行锁是在需要的时候才加上的，丹并不是不需要了就立刻释放，而是要等到事务结束了才释放，这个就是两阶段协议`**

> 如果业务中的事务需要处理多个行，最可能造成锁冲突、最可能影响并发度的锁尽量往后放。

### 3、死锁和死锁检测
> 当并发系统中不同线程出现资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致几个线程都进入无线等待的状态，称为死锁。

![](./img/4.png)
>事务A在等待事务B释放id= 2的行锁，而事务B在等待事务A释放id = 1的行锁，
事务A和事务B在互相等待对方的资源释放，就是进入死锁的状态，当出现死锁后，有两种策略:  
- 直接进入等待，直到超时，通过innodb_lock_wait_timeout 来设置，默认值50s
- 发起死锁检测，一旦发现死锁，主动回滚链条中的某一事务，让其他事务继续执行，将参数innodb_deadlock_detect 设置为on  表示开启这个逻辑。
> 1、innodb_lock_wait_timeout 需要设置合理的的值，时间设置太短，会出现很多误伤，时间太长，业务不合理   
> 2、如果所有的事务都更新同一行数据 ，每个新来的被堵住的线程，都要判断会不会由于自己的加入导致了死锁，这个时间复杂度是O(n)的操作，假设有1000个并发线程要同时更新同一行，那么死锁检测的操作就是100W量级的，虽然没有检测到死锁，但是消耗了大量的CPU资源，因此CPU利用率很高，但是每秒却执行不了几个事务。

- 如何解决由这种热点数据进行更新导致的性能问题？  
>1、确保业务一定不出现死锁，可以临时关闭死锁检测  
>2、控制并发度，对应相同行的更新，在进入引擎之前排队。这样在InnoDB内部就不会有大量的死锁检测工作了。
>3、将热更新的行数据拆分成逻辑上的多行来减少锁冲突，但是业务复杂度可能会大大提高

**`innodb行级锁是通过锁索引记录实现的，如果更新的列没建索引是会锁住整个表的。`**





