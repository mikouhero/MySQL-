# 14 |  count(*)这么慢，我该怎么办？

### 1、count(*) 的实现方式 

##### 1、1 不同引擎的实现方式 
> MyISAM 引擎把一个表的总行数存在了磁盘上，执行count(*) 的时候直接返回个数，效率高，`如果加了where条件 那么MyISAM也不能返回这么快`  
>InnoDB 引擎就麻烦了，它执行 count(*) 的时候需要把数据一行一行地从引擎里面读出来，然后计数     

##### 1、2 为什么 InnoDB 不跟 MyISAM 一样，也把数字存起来？
> 这是因为即使是在同一个时刻的多个查询，由于多版本并发控制（MVCC）的原因，InnoDB 表“应该返回多少行”也是不确定的。  
> InnoDB 是索引组织表，主键索引树的叶子节点是数据，而普通索引树的叶子节点是主键值，所以普通索引树比主键索引树小很多。对于count(*)这样的操作遍历哪个索引树得到的结果逻辑上都是一样的。因此，MySQLMySQL 优化器会找到最小的那棵树来遍历。`在保证逻辑正确的前提下，尽量减少扫描的数据量，是数据库系统设计的通用法则之一`    
> show table status 中table_rows的数据不准，不能直接使用  
- MyISAM表虽然count(*)很快，但是不支持事务；  
- show table status 命令虽然返回很快，但是不准确
- InnDB表直接count(*)会遍历全表，虽然结果准确，但会导致性能问题  

##### 1、3用缓存系统保存计数
> 将计数保存在缓存系统中的方式，还不只是丢失更新的问题。即使 Redis 正常工作，这个值还是逻辑上不精确的。

##### 1、4 不同count的用法 
`分析性能差别的原则`

- server层要什么就给什么  
- InnoDb 只给必要的值
- 现在的优化器只优化了 count(*) 的语义为“取行数”，其他“显而易见”的优化并没有做。


`对于 count(主键 id) 来说`，InnoDB 引擎会遍历整张表，把每一行的 id 值都取出来，返回给 server层。server 层拿到 id 后，判断是不可能为空的，就按行累加。  

`对于 count(1) 来说`，InnoDB 引擎遍历整张表，但不取值。server 层对于返回的每一行，放一个数字“1”进去，判断是不可能为空的，按行累加。

`对于 count(字段) 来说`：  
- 如果这个“字段”是定义为 not null 的话，一行行地从记录里面读出这个字段，判断不能为 null，按行累加；
- 如果这个“字段”定义允许为 null，那么执行的时候，判断到有可能是 null，还要把值取出来再判断一下，不是 null才累加

- 但是 count(*) 是例外，并不会把全部字段取出来，而是专门做了优化，不取值。count(*) 肯定不是 null，按行累加。  

`按照效率排序的话，count(字段)<count(主键id)<count(1)≈count(*)，所以建议，尽量使用 count(*)`























    


    


