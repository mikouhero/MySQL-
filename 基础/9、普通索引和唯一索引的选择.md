# 09 | 普通索引和唯一索引的选择？
### 1、查询过程
> 对于普通索引，查询满足条件的第一条记录，接着需要查找下一条记录，直至碰到不满足的为止。  
> 对于唯一索引，由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止继续检索。
> 查询的性能差别 忽略不计。

### 2、更新过程

#### 2.1 change buffer
> - 当需要更新一个数据页时，如果数据页在内存中则直接更新  
> - 不在内存中，在不影响数据一致性的前提下，InnoDB 会将这些更新操作缓存在 change buffer中，这样就不需从数据磁盘中读入这个数据页了。    下次查询需要访问的时候，将数据页读入内存，然后执行change buffer与这个页有关的操作，保证数据逻辑的正确性。  
> - change buffer :实际上可以持久化数据，在内存中拷贝也会写入磁盘。
> - 将change buffer 中的操作应用到原始的数据页，得到最新的结果称为merge ,系统后台也会定期merge ,数据库执行关闭时，也会执行merge 操作。

#### 2.2 什么条件可以使用 change buffer？
- 唯一索引的更新不能使用change buffer;所有的更新操作都要先判断这个操作是否违反唯一性约束，如果已经读入到内存了，那么直接更新内存会更快。 
- 普通索引可以使用；chage buffer 用的是change pool 中的内存，change buffer 的大小可以通过参数innodb_change_buffer_max_size动态设置。

##### 2.3插入一个新纪录的流程  
- 这个更新记录的目标页在内存中
>对于唯一索引，找到索引前后的之间的位置，判断到没有冲突，插入值，语句结束；  
>对于普通索引，找到索引前后的之间的位置，插入这个值，语句执行结束；      
- 这个更新记录的目标页 `不在`内存中
> 对于唯一索引来说，需要将数据页读入内存，判断到没有冲突，插入值，语句结束 ;  
> 对于普通索引来说，则是将更新记录在 change buffer  语句执行结束  

`将数据从磁盘读入内存涉及随机 IO 的访问，是数据库里面成本最高的操作之一。change buffer 因为减少了随机磁盘访问，所以对更新性能的提升是会很明显的。
`

#### 2.4 change buffer的使用场景
> change buffer 对更新过程有加速作用，仅限于在普通索引下使用。  
> merge 操作是真正进行数据更新的时候，change buffer 的主要目的就是将记录的操作缓存下来，所以在merge 之前 change buffer 越多越好。  
> 多写少读 ： 页面在写完以后马上被访问到的概率比较小，此时change buffer 的使用效果最好，这种业务模型常见的就是账单类、日志类的系统。  
> 多读少写 ：不太实用。

### 3、索引选择与实践
> 1、这两类索引在查询能力上是没有差别的  
> 2、主要考虑更新性能的影响 ，建议使用 普通索引   
> 3、有的更新后面，都马上伴随着对这个记录的查询，那么应该关闭 change buffer  
> 4、普通索引和 change buffer 的配合使用，对于数据量大的表更新优化很明显  

### 4、change buffer 和 redo log 
> redo log 主要节省的是随机写磁盘的 IO 消耗转成顺序写），而 change buffer 主要节省的则是随机读磁盘的 IO 消耗。











 




