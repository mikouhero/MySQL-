# 16 |  如何正确的显示随机消息

## 内存临时表 
> select word from words order by rand() limit 3;  // 10000条数据
#### 执行流程  
- 创建一个临时表。这个临时表使用的是 memory 引擎，表里有两个字段，第一个字段是
double 类型，为了后面描述方便，记为字段 R，第二个字段是 varchar(64) 类型，记为字段 W。并且，这个表没有建索引。  
- 从 words 表中，按主键顺序取出所有的 word 值  对于每一个 word 值，调用 rand() 函数生成一个大0 小于 1 的随机小数，并把这个随机小数和 word分别存入临时表的 R 和 W 字段中，到此，扫描行数是 10000
- 现在临时表有 10000 行数据了，接下来你要在这个没有索引的内存临时表上，按照字段 R 排序。
-  初始化 sort_buffer。sort_buffer 中有两个字段，一个是 double 类型，另一个是整型。
- 从内存临时表中一行一行地取出 R 值和位置信息，分别存入 sort_buffer 中的两个字段里。这个过程要对内存临时表做全表扫描，此时扫描行数增加 10000，变成了 20000。
- 在 sort_buffer 中根据 R 的值进行排序。注意，这个过程没有涉及到表操作，所以不会增加扫行数。
- 排序完成后，取出前三个结果的位置信息，依次到内存临时表中取出出 word 值，返回给客户端。这个过程中，访问了表的三行数据，总扫描行数变成了 20003。

`order by rand() 使用了内存临时表，内存临时表排序的时候使用了 rowid 排序方法`

## 磁盘临时表 
> tmp_table_size 这个配置限制了内存的临时表的大小，默认值是16M   
> 如果临时表大小超过了tmp_table_size ，那么内存临时表就会转成磁盘临时表  
> 磁盘临时表使用的引擎默认是 InnoDB，是由参数internal_tmp_disk_storage_engine控制的  
> 这个 SQL 语句的排序确实没有用到临时文件，用是 MySQL 5.6 版本引入的一个新的排序算法，即：：优先队列排序算法  
> 如果使用归并排序算法的话，虽然最终也能得到前 3 个值，但是这个算法结束后，已经将 10000 行数据都排好序了.
#### 执行流程 
- 对于这 10000 个准备排序的 (R,rowid)，先取前三行，构造成一个堆；
- 取下一个行 (R’,rowid’)，跟当前堆里面最大的 R 比较，如果 R’小于 R，把这个(R,rowid) 从堆中去掉，换成 (R’,rowid’)...
- 重复第 2 步，直到第 10000 个 (R’,rowid’) 完成比较。

## 随机排序方法 
#### 思路 
- 取得这个表的主键 id 的最大值 M 和最小值 N;
- 用随机函数生成一个最大值到最小值之间的数 X = (M-N)*rand() + N;
- 取不小于 X 的第一个 ID 的行。

`id 中间可能有空洞` 
- 取得整个表的行数，并记为 C。
- 取得 Y = floor(C * rand())。floor 函数在这里的作用，就是取整数部分
- 再用 limit Y,1 取得一行。




















































