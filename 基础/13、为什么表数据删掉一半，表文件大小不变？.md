# 13 | 为什么表数据删掉一半，表文件大小不变？
## 1、innodb_file_per_table 参数
> 表数据文件既可以存在共享表空间，也可以是单独的文件，这个行为是由参数  innodb_file_per_table 控制  
> 1、OFF   表的数据放在系统共享表空间，也就是跟数据字典放在一起；  
> 2、ON 每个 InnoDB 表数据存储在一个以 .ibd 为后缀的文的文件中。 从 MySQL 5.6.6 版本开始，它的默认ON  
- 建议设置成ON  因为，一个表单独存储为一个文件更容易管理，而且在你不需要这个表的时候，通过 drop table 命令，系统就会直接删除这个文件。而如果是放在共享表空间中，即使表删掉了，空间也是不不会回收的  

## 2、数据删除流程  
> 1、删除id = 100的记录 nnoDB 引擎只会把 100 这个记录标记为删除  如果之后要再插入一个 ID 在 300 和 600 之间的记录，可能会复用这个位置。但是，磁盘文件的大小并不会缩小。  
> 2、InnoDB 的数据是按页存储的，删除了一个页上的所有记录 整个数据页可以被复用  
- 数据页的复用跟记录的复用是不同的。
> 1、记录的复用，只限于符合范围条件的数据。  
> 2、而当整个页从 B+树里面摘掉以后，可以复用到任何位置。  
> 3、如果相邻的两个数据页利用率都很小，系统就会把这两个页上的数据合到其中一个页上，另外一个数据页就被标记为可复用。  
> 4 删除整个表的数据，所有的数据页标记为可复用，但是磁盘上文件大小不会改变  ，而没有被使用的空间，看起来就像是“空洞”。  
- 不止是删除数据会造成空洞，插入数据也会
> 1、如果数据是按照索引递增顺序插入的，那么索引是紧凑的。。但如果数据是随机插入的，就可能造成索引的数据页分裂      
>2 ，经过大量增删改的表，都是可能是存在空洞的。所以，如果能够把这些空洞去掉，就能达到收缩表空间的目的。
                                 
- 重建表，就可以达到这样的目的。

## 3 重建表 
> 1、建一个与表 A 结构相同的表 B，然后按照主键 ID递增的顺序，把数据一行一行地从表 A 里读出来再插入到表 B中   
> 2 alter table A engine=InnoDB 命令来重建表。在 MySQL 5.5 版本之前，这个命令的的执行流程跟我们前面描述的差不多，区别只是这个临时表 B 不需要你自己创建，MySQL 会自动完成转存数据、交换表名、删除旧表的操作  
> 3 、analyze table t 其实不是重建表，只是对表的索引信息做重新统计，没有修改数据，这个过程中加了MDL 读锁；  
> 4、 optimize table t 等于 recreate+analyze
                         
                                
     
    
    
                                  
     
