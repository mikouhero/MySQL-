# 15 |  order_by 是怎么工作的

### 全字段排序 
> 已知表数据结构 id(主键)、city(索引)、name,age,addr   
> select city,name,age from t where city='杭州' order by name limit 1000 ;

执行流程  
- 初始化 sort_buffer，确定放入 name、city，age这三个字段  
- 从索引city上找到第一个满足条件的主键id  
- 到主键id索引取出整行，取name,city age 三个字段的值，存入sort_buffer   
- 从索引上取下一条记录id  
- 重复操作，直到不满足条件  
- 对sort_buffer 中的数据 `按照字段name 做快速排序`
- 按照排序结果取出前1000 行返回给客户端 

> 上述流程中按照name字段排序这个动作，可能早内存中完成，也可能需要使用外部索引，取决于所需的内存和参数 sort_buffer_size   
> sort_buffer_size 就是MySQL 为排序开辟的内存（sort_buffer）的大小。如果要排序的数据量小于 sort_buffer_size，排序就在内存中完成。但如果排序数据量太大，内存放不下，则不得不利用磁盘临时文件辅助排序。
> 通过 number_of_tmp_files中查看是否使用了临时文件,number_of_tmp_files 就是 0，表示排序可以直接在内存中完成 ，数字 N 表示 ，`MySQL 将需要排序的数据分成 1N 份，每一份单独排序后存在这些临时文件中。然后把这 N 个有序文件再合并成一个有序的大文件`。

### rowid 排序 
> 基于全字段排序，如果查询的结果字段很多的话那么sort_buffer里面放的字段太多，这样内存里放的行数就会很少，要分成很多临时文件，排序性能很差 。

max_length_for_sort_data，是 MySQL 中专门控制用于排序的行数据的长度的一个参数。它的意思是如果单行的长度超过这个值，MySQL 就认为单行太大，要换一个算法   
新的算法是将排序的字段和主键id 放入sort_buffer中  
- 初始化 sort_buffer，确定放入 name、id 这两个字段  
- 从索引city上找到第一个满足条件的主键id  
- 到主键id索引取出整行，取name,city age 三个字段的值，存入sort_buffer   
- 从索引上取下一条记录id  
- 重复操作，直到不满足条件  
- 对sort_buffer 中的数据 `按照字段name 做快速排序`
- 遍历排序结果，取前 1000 行，并按照 id 的值回到原表中取出 city、name 和 age 三个字段返回给客户端

### 全字段排序 VS rowid 字段排序
- 如果 MySQL 实在是担心排序内存太小，会影响排序效率，才会采用 rowid排序算法，这样排序过程中一次可以排序更多行，但是需要再回到原表去取数据  
- 如果 MySQL 认为内存足够大，会优先选择全字段排序，把需要的字段都放到 sort_buffer 中，这样排序后就会直接从内存里面返回查询结果了，不用再回到原表去取数据。

`MySQL 的一个设计思想：如果内存够，就要多利用内存，尽量减少磁盘访问。`
 - 对于 InnoDB 表来说，rowid 排序会要求回表多造成磁盘读，因此不会被优先选择。


### 联合索引  

并不是所有的oredr_by 语句都是需要排序操作的，从上面分析执行过程，之所以MySQL 需要生成临时表，并且在临时表上做排序操作--` 原来的数据是无序的` 

创建一个city name age 的联合索引，这时，对于 city 字段的值相同的行来说，还是按照 name 字段的值递增排序的，此时的查询语句也就不再需要排序了
-  从索引 (city,name,age) 找到第一个满足city='杭州’条件的记录，取出其中的 city、name 和 age 这三个字段的值，作为结果集的一部分直接返回；
- 从索引 (city,name,age) 取下一个记录，同样取出这三个字段的值，作为结果集的一部分直接返回；
- 重复执行步骤 2，直到查到第 1000 条记录，或者是不满足条件时循环结束
当然，这里并不是说要为了每个查询能用上覆盖索引，就要把及的字段都建上联合索引，毕竟索引还是有维护代价的。






















