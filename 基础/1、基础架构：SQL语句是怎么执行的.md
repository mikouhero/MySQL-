# 01 | 基础架构：一条SQL查询语句是如何执行的？

### 1、MySQL 的逻辑架构图

![](./1.png)

>从图中可以看出，MySQL 可以分为 Server 层和存储引擎层两部分

### 2、Server层
>Server层包括、分析器、优化器、执行器等,涵盖 MySQL 的大多数核心服务功能，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等

##### 2.1 连接器
>顾名思义，连接器是负责服务端与客户端建立连接的。在连接过程中 获取权限，维持和管理连接。

>连接命令
```html
    mysql -h127.0.0.1 -P3306 -uroot -p
```
>完成TCP握手后，连接器开始认证用户的密码，完成认证后，连接器会到权限表里面查出你拥有的权限，之后所操作的权限都依赖此时获取到的权限，这就说明当管理员对当前用户的权限进行了修改也不会影响此时存在的连接权限。  
>连接完成后，如果没有后续的动作，这个链接就处于空闲状态，通过show processlist命令查看。若客户端长时间没动静，连接器会自动断开，这个时间是由参数wait_timeout 控制 默认8小时。  
>由于连接的过程通常比较复杂，所以应当尽量减少建立连接的动作，也就是尽量使用长连接。
>>使用长连接后，MySQL占用内存涨的特别快？
>>>MySQL 在执行过程中使用的内存是管理在连接对象里的，这些资源只有在断开的时候才释放，所以长连接累积下来，可能导致内存占用太大，被系统强行杀掉，从现象上看就是MySQL异常重启。解决办法
>>>>1、定期断开长连接。  
>>>>2、MySQL版本> 5.7,在每次执行一个较大的操作后，执行mysql_reset_connection重新初始化资源，此时不需要重连和权限认证，但是会将连接恢复到刚刚创建完成的状态。

##### 2.2 查询缓存

>MySQL拿到查询请求:
>>缓存中是否存在？
>>>存在，之前的语句和结果以key-val形式存在内存中，key 存在，val 直接返回客户端。  
>>> 不存在，执行后面的阶段，执行完成会将执行结果存在查询缓存中。  

`大多数情况建议不使用查询缓存-->弊大于利`
>查询缓存的失效非常频繁。只要一个表更新了，那么这个表上所有的查询缓存都会被清空。那么就可能当你刚写入缓存时，还没使用就被一个更新全部清空了。对于更新压力大的数据库来说，查询缓存的命中率会非常低。但是试用于静态表，很长时间更新一次，那么才适合使用查询缓存。  
将参数query_cache_type 设置成 **`DEMAND`**，这样对于默认的SQL语句都不会使用查询缓存，而对于你确定要使用的查询缓存的语句 可以使用 SQL_CACHE 显示指定 
```html
    select SQL_CACHE * from table where id =1
```
`MySQL版本8.0+ 直接将查询缓存的整个功能删除了`

##### 2.3 分析器
>分析器先做语法分析，输入的多个字符串和空格组成的一条SQL语句，MySQL需要识别里面的字符串分别是什么 代表什么 ，根据分析的结果，语法分析器会根据语法规则判断你输入的SQL语句是否满足MySQL 语法

##### 2.4优化器
>优化器是在表里有多个索引的时候，决定使用哪个索引；或者在多表关联join的时候，决定各个表的连接顺序。
```html
    select * from t1 join t2 using(ID)  where t1.c=10 and t2.d=20;
```
* 先从表 t1 里面取出 c=10 的记录的 ID 值，再根据 ID 值关联到表 t2，再判断 t2 里面d 的值是否等于 20

* 先从表 t2 里面取出 d=20 的记录的 ID 值，再根据 ID 值关联到 t1，再判断 t1 里面 c的值是否等于10 

> 这两张执行的结果是一样的，但是效率是不同的，而优化器的作用就是决定选择使用哪一个方案。

##### 2.5执行器
>开始执行的时候，要先判断一下你对这个表 T 有没有执行查询的权限？
>> 没有。终止
>>  有。打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口

### 3、存储引擎层

>其架构模式是插件式的，支持 InnoDB、MyISAM、MyISAM、Memory 等多个存储引擎。MySQL 5.5.5版本的默认引擎是InnoDB.







